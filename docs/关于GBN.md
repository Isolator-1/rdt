# 关于GBN

学号：1911396

姓名：曾泉胜

---

> 【警告】GBN的实现存在bug，由于时间原因，本人暂时将重点放在类TCP协议上，该部分日后修改（2021年12月10日）

本次实验我直接完成了回退N步（GBN）的滑动窗口协议。**当其窗口大小为1，序号空间为[0,1]时，就是一个停等协议**。使用该协议，完成了单向的文件传输。

## 协议设计

协议结构如下所示，总长度为10240字节，显然，在后续的实验中，还要添加更多字段。

```c++
#define DATA_SIZE 10231
#define ACK_FLAG 0x1
#define FIN_FLAG 0x2
#define SYN_FLAG 0x4

#pragma pack(1)
struct rdt_t
{
    uint16_t sum = 0;           // 校验和
    uint8_t flag = 0;           // 标志位
    uint32_t seqnum = 0;        // 序列号
    uint16_t dataLen = 0;       // 数据长度
    uint8_t data[DATA_SIZE] = {0}; // 数据
};
#pragma pack()

```

### 打包与解包

在发送前打包数据时计算校验和：每2字节读取打包后的协议包，加到校验和字段，溢出则回卷。

在接收后，使用相同的算法，计算出校验和并与校验和字段比较。该算法可以发现一位错，一位错也是大概率事件。

## 符号/名词解释

| 符号             | 含义                                                  |
| ---------------- | ----------------------------------------------------- |
| `base`           | 滑动窗口中第一个已发送待确认数据包的序列号，初始为0   |
| `nextseqnum`     | 滑动窗口中最后一个已发送待确认数据包的序列号，初始为0 |
| `N`              | 滑动窗口大小                                          |
| `NUM_SEQNUM`     | 序列号空间为`[0, NUM_SEQNUM-1]`，至少为`2N`           |
| `TIMEOUT`        | 发送方超时重发时间                                    |
| `INTEVAL`        | 检查定时器的时间间隔                                  |
| `expectedseqnum` | 接收方期望的序列号，初始为0                           |
| `sendto`         | winsock提供的udp发送函数，不可靠                      |
| `rdt_send`       | 自己写的可靠发送函数                                  |

## 程序设计

我的GBN发送方和接收方在建立连接后与断开连接前与教材上的描述没有什么差别，不过在数据结构，事件响应上，我的设计和实现方案如下：

### 发送方

发送方有3个需要相应的事件，理论上描述如下：

| 事件                       | 处理线程 | 动作                                                         |
| -------------------------- | -------- | ------------------------------------------------------------ |
| 上层调用`rdt_send`         | 主线程   | 如果滑动窗口满了，阻塞；如果滑动窗口未满，封装序号为nextseqnum的数据包并放入滑动窗口的相应位置（注意该位置可能由于滑动窗口没有前推而导致已经存在了一个数据包），在放入数据包后使得滑动窗口满了，则启动计时器。 |
| 收到一个包                 | 接收线程 | 如果收到的确认序号不是base的下一个位置，什么也不做；只有收到的确认序号是base的下一个时，才“前推”滑动窗口，之后如果没有待确认的数据包，则停止计时，否则重启定时器。 |
| 计时器启动，且到达超时时间 | 计时线程 | 重新发送所有已发送但是未确认的数据包。                       |

在实现中，一些细节的处理并没有那么轻松：

滑动窗口的大小是固定的，但是需要在数据包序列上滑动，于是我使用**数组存储的循环队列**保存已发送但是未确认的数据包，这个循环队列的容量是滑动窗口的大小N，使用数组存储是为了满足收到冗余ACK时，能够随机访问之前发过的一个包。滑动窗口的“前推”事实上是由两个步骤完成的：在接收线程中，收到确认序号为`(base＋1)%(NUM_SEQNUM)`时，`base`才会更新为该值，同时循环队列将队首出队，滑动窗口“左消”；在主线程中，序号为`nextseqnum`的数据包应当放在循环队列的`(nextseqnum-base+NUM_SEQNUM)%NUM_SEQNUM`时，只有当该值为循环队列的大小时，才会入队一个新的数据包，将`nextseqnum`更新为 `(nextseqnum + 1) % NUM_SEQNUM`，滑动窗口“右长”。

此外，序号空间的大小至少为滑动窗口大小的两倍，不能简单使用循环队列的大小来得到发送方下次发送的序列号，需要单独维护`base`和`nextseqnum`在序号空间中此消彼长。`base`到`nextseqnum`的距离总是等于循环队列的大小，在`DEBUG`模式下，我的程序测试了这一点，说明各个线程对循环队列的访问是串行化的，没有出现不同步的问题。

定时器本质上就是记录了开始时间，经过一个`INTEVAL`的间隔检查一下距离开始时间有多久，超过`TIMEOUT`则超时， 由于主线程和接收线程都会阻塞，因此计时器需要一个单独的“守护”线程。

### 接收方

GBN的接收方只有一个任务：收到数据包，校验并将其序列号与自己期望的序列号`expectedseqnum`比对，如果相同，则接收该数据包，`expectedseqnum`更新为`(expectedseqnum + 1) % NUM_SEQNUM`；否则，抛弃该数据包。最后向发送方发回序号为`expectedseqnum`的ACK。~~主线程中就可以搞定~~。

实验表明，如果接收方使用单线程，当窗口大小比较大（在我的机器上>8）时，接收方会“漏听”发来的数据包。因此应当启动一个用于接收的守护线程，并维护一个接收、发送线程同步访问的缓冲队列。

## 连接与断开连接

由于是单向传输，即**接收端不需要保证自己发出的数据包发送端一定会收到**，我没有把连接与断开连接的过程做得那么复杂。我在发送端统计文件传输时间，从确认连接后开始，到收到FIN ACK截止。

### 连接

发送端启动接收线程但主线程中开始发送数据之前，先不断发送（`sendto`）带有SYN标记的数据包，直到接收线程收到了接收方返回的带有SYN ACK标记的数据包。之后就不必要回复ACK而直接开始发送数据就可以了，因为接收方不在乎它发的数据包能不能可靠到达发送方。

### 断开连接

在发送方的主线程读完文件时，使用`rdt_send`发出FIN包，与SYN包不同的是，FIN包带有序列号，FIN包发出时，之前的包可能还没有到达或者准备重发，只有发送方收到接收方回复的FIN ACK后，才能结束接收线程，结束主线程。

